  display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 12px;
    }
    .output-item video {
      width: 100%;
      border-radius: 8px;
      background: #111827;
    }
    .output-item strong {
      font-size: 12px;
    }
    .pill {
      font-size: 11px;
      border-radius: 999px;
      padding: 2px 7px;
      background: #eff6ff;
      color: #1d4ed8;
    }
    .hint {
      font-size: 11px;
      color: #6b7280;
      margin-top: 6px;
    }
    .cta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 8px;
      margin-top: 6px;
    }
    .cta-grid input {
      width: 100%;
    }
    .inline-note {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: #4b5563;
      background: #eef2ff;
      padding: 6px 10px;
      border-radius: 8px;
      margin-top: 6px;
    }
    .error {
      color: #b91c1c;
      font-size: 12px;
      margin-top: 6px;
    }
    .divider {
      height: 1px;
      background: #e5e7eb;
      margin: 18px 0 14px;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Ad Clip Generator</h1>
    <div class="subtitle">
      Upload one long video and export up to <strong>3 clips</strong> (15–40s) in
      <strong>16:9</strong>, <strong>9:16</strong>, and <strong>1:1</strong> formats, ready for ads.
    </div>

    <div class="grid">
      <!-- LEFT: INPUTS -->
      <div class="card">
        <h2>1. Source video</h2>
        <div class="field">
          <label for="videoFile">Upload main video</label>
          <input type="file" id="videoFile" accept="video/*" />
          <small>Use a single high-quality MP4 / MOV or similar.</small>
        </div>

        <div class="field">
          <label for="presetProfile">Preset profiles</label>
          <select id="presetProfile">
            <option value="custom">Custom</option>
            <option value="meta">Meta Ads pack (15s · 9:16 + 1:1)</option>
            <option value="youtube">YouTube pack (30s · 16:9)</option>
          </select>
          <small>Presets auto-select clip length and aspect ratios for common platforms.</small>
        </div>

        <div class="field">
          <label>Clip length (seconds)</label>
          <div style="display:flex; gap:8px;">
            <input
              type="number"
              id="clipLength"
              min="15"
              max="40"
              value="30"
            />
            <div style="font-size:12px; color:#6b7280; display:flex; align-items:center;">
              Min 15 · Max 40
            </div>
          </div>
          <small>All generated clips will use this duration.</small>
        </div>

        <div class="field">
          <label>Number of base clips</label>
          <input
            type="number"
            id="clipCount"
            min="1"
            max="3"
            value="3"
@@ -263,128 +293,254 @@
        </div>

        <div class="field">
          <label>Aspect ratios to export</label>
          <div class="checkbox-row">
            <label>
              <input type="checkbox" class="ratio-option" value="16:9" checked />
              <span>16:9 Horizontal</span>
            </label>
            <label>
              <input type="checkbox" class="ratio-option" value="9:16" checked />
              <span>9:16 Vertical (Shorts / Reels)</span>
            </label>
            <label>
              <input type="checkbox" class="ratio-option" value="1:1" />
              <span>1:1 Square</span>
            </label>
          </div>
          <small>
            You’ll get separate files per base clip + selected ratio.
          </small>
        </div>

        <div class="divider"></div>

        <h2>Brand overlays</h2>
        <div class="field">
          <label for="logoFile">Brand logo (PNG/JPG)</label>
          <input type="file" id="logoFile" accept="image/*" />
          <small>Optional. The logo is scaled and placed in the top-left corner of every clip.</small>
        </div>

        <div class="field">
          <label>CTA text per base clip</label>
          <div class="cta-grid">
            <input class="cta-input" data-index="1" placeholder="Clip 1 CTA (e.g. Shop now)" />
            <input class="cta-input" data-index="2" placeholder="Clip 2 CTA (e.g. Learn more)" />
            <input class="cta-input" data-index="3" placeholder="Clip 3 CTA (e.g. Subscribe)" />
          </div>
          <small>CTA badges render in the lower-right of each exported file. Leave blank to skip.</small>
        </div>

        <div class="divider"></div>

        <h2>2. Generate</h2>
        <button id="generateBtn">
          <span id="btnLabel">Generate Ad Clips</span>
        </button>

        <div class="status" id="status">
          <div class="badge">
            <span></span>
            <span>Idle – upload a video to begin</span>
          </div>
        </div>
        <div class="error" id="error"></div>
      </div>

      <!-- RIGHT: OUTPUTS -->
      <div class="card">
        <div class="output-header">
          <h2>3. Output clips</h2>
          <div class="chips">
            <div class="chip">Min length: 15s</div>
            <div class="chip">Max length: 40s</div>
            <div class="chip">Max base clips: 3</div>
          </div>
        </div>
        <div id="meta" class="hint"></div>
        <div class="output-grid" id="outputGrid"></div>
        <p class="hint">
          Each clip is re-encoded as H.264 MP4 with the selected aspect ratio, ready
          for platforms like YouTube, TikTok, Meta, and display ads.
        </p>
      </div>
    </div>

    <!-- Hidden video just to read duration -->
    <video id="probeVideo" style="display:none;"></video>

    <script>
      // UI refs
      const fileInput = document.getElementById("videoFile");
      const clipLengthInput = document.getElementById("clipLength");
      const clipCountInput = document.getElementById("clipCount");
      const ratioCheckboxes = document.querySelectorAll(".ratio-option");
      const presetSelect = document.getElementById("presetProfile");
      const logoInput = document.getElementById("logoFile");
      const ctaInputs = document.querySelectorAll(".cta-input");
      const generateBtn = document.getElementById("generateBtn");
      const btnLabel = document.getElementById("btnLabel");
      const statusEl = document.getElementById("status");
      const errorEl = document.getElementById("error");
      const outputGrid = document.getElementById("outputGrid");
      const metaEl = document.getElementById("meta");
      const probeVideo = document.getElementById("probeVideo");

      let ffmpeg = null;
      let sourceFile = null;
      let sourceUrl = null;
      let videoDuration = null;
      let logoFile = null;

      function setStatus(text, mode = "info") {
        const colors = {
          info: "#6b7280",
          work: "#1d4ed8",
          ok: "#16a34a",
          warn: "#b45309",
        };
        statusEl.innerHTML = `
          <div class="badge" style="background:${mode === "work" ? "#eef2ff" : "#eff6ff"}; color:${colors[mode]};">
            <span style="background:${colors[mode]};"></span>
            <span>${text}</span>
          </div>
        `;
      }

      function setError(msg) {
        errorEl.textContent = msg || "";
      }

      function clamp(num, min, max) {
        return Math.min(Math.max(num, min), max);
      }

      function enforceNumberInput(input, min, max, fallback) {
        let val = parseFloat(input.value);
        if (Number.isNaN(val)) val = fallback;
        const clamped = clamp(val, min, max);
        if (clamped !== val) {
          input.value = clamped;
          setStatus(
            `Adjusted ${input.id} to ${clamped} (allowed: ${min}–${max}).`,
            "warn"
          );
        }
        return clamped;
      }

      function readFileAsDataURL(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(new Error("Failed to read file"));
          reader.readAsDataURL(file);
        });
      }

      function loadImageFromDataURL(dataUrl) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error("Could not load image"));
          img.src = dataUrl;
        });
      }

      function dataURLToUint8Array(dataUrl) {
        const base64 = dataUrl.split(",")[1];
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
          bytes[i] = binary.charCodeAt(i);
        }
        return bytes;
      }

      async function imageFileToPNGBytes(file, targetWidth = 260) {
        const dataUrl = await readFileAsDataURL(file);
        const img = await loadImageFromDataURL(dataUrl);
        const scale = Math.min(1, targetWidth / img.width);
        const width = Math.round(img.width * scale);
        const height = Math.round(img.height * scale);
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0, width, height);
        const png = canvas.toDataURL("image/png");
        return dataURLToUint8Array(png);
      }

      function createCtaOverlay(text, ratio) {
        if (!text || !text.trim()) return null;
        const clean = text.trim().slice(0, 80);
        const canvas = document.createElement("canvas");
        const isVertical = ratio === "9:16";
        const isSquare = ratio === "1:1";
        canvas.width = isVertical ? 640 : isSquare ? 680 : 880;
        canvas.height = isVertical ? 180 : 160;
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        const radius = 18;
        const w = canvas.width;
        const h = canvas.height;
        ctx.beginPath();
        ctx.moveTo(radius, 0);
        ctx.lineTo(w - radius, 0);
        ctx.quadraticCurveTo(w, 0, w, radius);
        ctx.lineTo(w, h - radius);
        ctx.quadraticCurveTo(w, h, w - radius, h);
        ctx.lineTo(radius, h);
        ctx.quadraticCurveTo(0, h, 0, h - radius);
        ctx.lineTo(0, radius);
        ctx.quadraticCurveTo(0, 0, radius, 0);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "#16a34a";
        ctx.fillRect(18, h / 2 - 22, 44, 44);
        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.moveTo(32, h / 2 - 6);
        ctx.lineTo(48, h / 2);
        ctx.lineTo(32, h / 2 + 6);
        ctx.closePath();
        ctx.fill();

        ctx.font = "28px 'Inter', 'Segoe UI', system-ui";
        ctx.fillStyle = "white";
        ctx.textBaseline = "middle";
        ctx.fillText(clean, 76, h / 2);

        const png = canvas.toDataURL("image/png");
        return dataURLToUint8Array(png);
      }

      async function ensureFFmpeg() {
        if (ffmpeg && ffmpeg.isLoaded && ffmpeg.isLoaded()) return;
        if (!window.FFmpeg) {
          throw new Error("FFmpeg.wasm script not loaded.");
        }
        const { createFFmpeg, fetchFile } = FFmpeg;
        window._ffmpegFetchFile = fetchFile;
        ffmpeg = createFFmpeg({ log: true });
        setStatus("Loading FFmpeg engine in the background…", "work");
        await ffmpeg.load();
        setStatus("FFmpeg ready. Configure your clips and click Generate.", "ok");
      }

      // Read duration from the uploaded file using a hidden video element
      function probeDuration(file) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(file);
          probeVideo.src = url;
          probeVideo.onloadedmetadata = () => {
            const dur = probeVideo.duration;
            if (!isFinite(dur) || dur <= 0) {
              reject(new Error("Could not read video duration."));
            } else {
              resolve(dur);
            }
@@ -403,243 +559,353 @@
          setStatus("Idle – upload a video to begin");
          return;
        }

        try {
          setStatus("Reading video metadata…", "work");
          const duration = await probeDuration(file);
          sourceFile = file;
          videoDuration = duration;

          if (sourceUrl) URL.revokeObjectURL(sourceUrl);
          sourceUrl = URL.createObjectURL(file);

          metaEl.innerHTML = `
            <strong>Source:</strong> ${file.name} · ${(file.size / (1024 * 1024)).toFixed(1)} MB<br>
            <strong>Duration:</strong> ${duration.toFixed(1)} seconds
          `;
          setStatus("Video loaded. You can configure clip length and count.", "ok");
        } catch (err) {
          console.error(err);
          setError(err.message || "Failed to read video.");
          setStatus("Error loading video.", "warn");
        }
      });

      presetSelect.addEventListener("change", (e) => {
        applyPreset(e.target.value);
      });

      logoInput.addEventListener("change", (e) => {
        logoFile = e.target.files[0] || null;
        if (logoFile) {
          setStatus(`Logo loaded: ${logoFile.name}`, "info");
        }
      });

      // Compute start times for each base clip, spaced across the duration
      function computeClipPlan(totalDuration, clipLength, requestedClips) {
        const safeLen = clamp(clipLength, 15, 40);
        const maxClipsByTime = Math.max(1, Math.floor(totalDuration / safeLen));
        const clipCount = clamp(requestedClips, 1, Math.min(3, maxClipsByTime));

        const available = totalDuration - safeLen;
        let starts = [];
        if (available <= 0) {
          starts = [0];
        } else if (clipCount === 1) {
          starts = [available / 2];
        } else {
          const spacing = available / (clipCount - 1);
          for (let i = 0; i < clipCount; i++) {
            starts.push(spacing * i);
          }
        }

        return {
          clipLength: safeLen,
          clips: starts.map((s, idx) => ({ index: idx + 1, start: s })),
        };
      }

      function getSelectedRatios() {
        const vals = [];
        ratioCheckboxes.forEach((cb) => {
          if (cb.checked) vals.push(cb.value);
        });
        return vals;
      }

      function setRatios(ratios) {
        ratioCheckboxes.forEach((cb) => {
          cb.checked = ratios.includes(cb.value);
        });
      }

      function applyPreset(preset) {
        if (preset === "meta") {
          clipLengthInput.value = 15;
          setRatios(["9:16", "1:1"]);
          setStatus("Applied Meta Ads pack (15s, 9:16 + 1:1).", "info");
        } else if (preset === "youtube") {
          clipLengthInput.value = 30;
          setRatios(["16:9"]);
          setStatus("Applied YouTube pack (30s, 16:9).", "info");
        } else {
          setStatus("Custom mode. Adjust clip length, count, and ratios.", "info");
        }
      }

      function getFilterForRatio(ratio) {
        // Scale to cover and crop to the target aspect for ad-friendly resolutions.
        switch (ratio) {
          case "16:9":
            return "scale=1920:1080:force_original_aspect_ratio=cover,crop=1920:1080";
          case "9:16":
            return "scale=1080:1920:force_original_aspect_ratio=cover,crop=1080:1920";
          case "1:1":
            return "scale=1080:1080:force_original_aspect_ratio=cover,crop=1080:1080";
          default:
            return null;
        }
      }

      async function generateClips() {
        setError("");

        if (!sourceFile || !videoDuration) {
          setError("Please upload a source video first.");
          return;
        }

        let clipLen = parseFloat(clipLengthInput.value);
        if (Number.isNaN(clipLen)) clipLen = 30;
        let clipCount = parseInt(clipCountInput.value, 10);
        if (Number.isNaN(clipCount)) clipCount = 3;
        const clipLen = enforceNumberInput(clipLengthInput, 15, 40, 30);
        const clipCount = enforceNumberInput(clipCountInput, 1, 3, 3);

        const ratios = getSelectedRatios();
        if (ratios.length === 0) {
          setError("Select at least one aspect ratio.");
          return;
        }

        const ctaTexts = {};
        ctaInputs.forEach((input) => {
          const idx = Number(input.dataset.index);
          if (idx) ctaTexts[idx] = input.value.trim();
        });

        const plan = computeClipPlan(videoDuration, clipLen, clipCount);
        if (!plan.clips.length) {
          setError("Unable to compute clip segments from this video.");
          return;
        }

        const startSummary = plan.clips
          .map((c) => `${c.index}: ${c.start.toFixed(1)}s`)
          .join(", ");
        metaEl.innerHTML = `
          <strong>Plan:</strong> ${plan.clips.length} clip(s) · ${plan.clipLength.toFixed(1)}s each<br>
          <strong>Starts:</strong> ${startSummary}<br>
          <strong>Ratios:</strong> ${ratios.join(", ")}
        `;

        // UI state
        generateBtn.disabled = true;
        btnLabel.textContent = "Processing…";
        setStatus(
          `Preparing ${plan.clips.length} base clip(s) of ${plan.clipLength.toFixed(
            1
          )}s each in ${ratios.join(", ")}…`,
          "work"
        );
        outputGrid.innerHTML = "";

        try {
          await ensureFFmpeg();

          // Write input file once
          const fetchFile = window._ffmpegFetchFile;
          const inputName = "input_video";
          const ext = (sourceFile.name.split(".").pop() || "mp4").toLowerCase();
          const inputFileName = `${inputName}.${ext}`;

          ffmpeg.FS("writeFile", inputFileName, await fetchFile(sourceFile));

          // Brand logo
          let logoPath = null;
          if (logoFile) {
            const logoBytes = await imageFileToPNGBytes(logoFile, 280);
            logoPath = "brand_logo.png";
            ffmpeg.FS("writeFile", logoPath, logoBytes);
          }

          const outputs = [];
          const ctaCache = new Map();

          for (const clip of plan.clips) {
            for (const ratio of ratios) {
              const vf = getFilterForRatio(ratio);
              if (!vf) continue;

              const safeStart = Math.max(0, clip.start);
              const durationArg = plan.clipLength.toFixed(2);
              const startArg = safeStart.toFixed(2);

              const suffix =
                ratio === "16:9" ? "h" : ratio === "9:16" ? "v" : "sq";
              const outName = `clip_${clip.index}_${suffix}.mp4`;

              const ctaKey = `${clip.index}_${ratio}`;
              let ctaPath = null;
              if (ctaTexts[clip.index]) {
                if (!ctaCache.has(ctaKey)) {
                  const overlayBytes = createCtaOverlay(ctaTexts[clip.index], ratio);
                  if (overlayBytes) {
                    const overlayName = `cta_${ctaKey.replace(":", "x")}.png`;
                    ffmpeg.FS("writeFile", overlayName, overlayBytes);
                    ctaCache.set(ctaKey, overlayName);
                  }
                }
                ctaPath = ctaCache.get(ctaKey) || null;
              }

              setStatus(
                `Rendering clip ${clip.index} (${ratio})… (${startArg}s → +${durationArg}s)`,
                "work"
              );

              // ffmpeg command: trim & resize
              const inputArgs = ["-ss", startArg, "-t", durationArg, "-i", inputFileName];
              const filterSteps = [`[0:v]${vf}[v0]`];
              let currentLabel = "v0";
              let nextInputIndex = 1;

              if (logoPath) {
                inputArgs.push("-i", logoPath);
                filterSteps.push(
                  `[${nextInputIndex}:v]scale=240:-1[logo];[${currentLabel}][logo]overlay=16:16[v1]`
                );
                currentLabel = "v1";
                nextInputIndex += 1;
              }

              if (ctaPath) {
                inputArgs.push("-i", ctaPath);
                filterSteps.push(
                  `[${nextInputIndex}:v]scale=iw:ih[cta];[${currentLabel}][cta]overlay=x=W-w-24:y=H-h-24[vout]`
                );
                currentLabel = "vout";
                nextInputIndex += 1;
              }

              const filterComplex = filterSteps.join(";");

              await ffmpeg.run(
                "-ss",
                startArg,
                "-t",
                durationArg,
                "-i",
                inputFileName,
                "-vf",
                vf,
                ...inputArgs,
                "-filter_complex",
                filterComplex,
                "-map",
                `[${currentLabel}]`,
                "-map",
                "0:a?",
                "-r",
                "30",
                "-c:v",
                "libx264",
                "-preset",
                "veryfast",
                "-crf",
                "23",
                "-c:a",
                "aac",
                "-b:a",
                "128k",
                outName
              );

              const data = ffmpeg.FS("readFile", outName);
              const blob = new Blob([data.buffer], { type: "video/mp4" });
              const url = URL.createObjectURL(blob);

              outputs.push({
                url,
                fileName: outName,
                clipIndex: clip.index,
                ratio,
                start: safeStart,
                length: plan.clipLength,
                hasLogo: Boolean(logoPath),
                cta: ctaTexts[clip.index],
              });

              // Clean FS entry to save memory
              ffmpeg.FS("unlink", outName);
            }
          }

          // Optional: clean input from FS
          try {
            ffmpeg.FS("unlink", inputFileName);
          } catch (e) {
            /* ignore */
          }
          if (logoPath) {
            try {
              ffmpeg.FS("unlink", logoPath);
            } catch (e) {
              /* ignore */
            }
          }
          ctaCache.forEach((path) => {
            try {
              ffmpeg.FS("unlink", path);
            } catch (e) {
              /* ignore */
            }
          });

          // Render outputs to UI
          outputGrid.innerHTML = "";
          outputs.forEach((out) => {
            const item = document.createElement("div");
            item.className = "output-item";
            item.innerHTML = `
              <video controls src="${out.url}"></video>
              <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                  <strong>Clip ${out.clipIndex}</strong>
                  <span class="pill">${out.ratio}</span>
                </div>
                <div style="font-size:11px; color:#6b7280;">
                  ${out.length.toFixed(1)}s<br>
                  from ${out.start.toFixed(1)}s
                </div>
              </div>
              <div style="display:flex; justify-content:space-between; align-items:center; gap:6px;">
                <span style="font-size:11px; color:#4b5563; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">
                  ${out.fileName}
                </span>
                <a
                  href="${out.url}"
                  download="${out.fileName}"
                  style="font-size:11px; text-decoration:none; padding:4px 8px; border-radius:999px; background:#111827; color:white;"
                >
                  Download
                </a>
              </div>
              <div class="inline-note" style="width:100%; box-sizing:border-box;">
                ${out.hasLogo ? "Logo overlay" : "No logo"} ·
                ${out.cta ? `CTA: ${out.cta}` : "No CTA"}
              </div>
            `;
            outputGrid.appendChild(item);
          });

          setStatus(
            `Done. Generated ${outputs.length} ad-ready file(s) from ${plan.clips.length} base clip(s).`,
            "ok"
          );
        } catch (err) {
          console.error(err);
          setError(err.message || "Unexpected error while processing video.");
          setStatus("Processing failed.", "warn");
        } finally {
          generateBtn.disabled = false;
          btnLabel.textContent = "Generate Ad Clips";
        }
      }

      generateBtn.addEventListener("click", () => {
        generateClips();
      });
    </script>
  </div>
</body>
</html>
